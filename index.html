<script type="module">
(async () => {
  // ---------- DOM ready ----------
  if (document.readyState === "loading") {
    await new Promise(r => document.addEventListener("DOMContentLoaded", r, { once: true }));
  }

  // ---------- Silence /favicon.ico 404 on GH Pages ----------
  if (!document.querySelector('link[rel="icon"]')) {
    const a = document.createElement('link'); a.rel = 'icon'; a.href = 'data:image/x-icon;,';
    document.head.appendChild(a);
  }
  if (!document.querySelector('link[rel="shortcut icon"]')) {
    const b = document.createElement('link'); b.rel = 'shortcut icon'; b.href = 'data:image/x-icon;,';
    document.head.appendChild(b);
  }

  // ---------- Canvases ----------
  const gl = document.getElementById('gl');
  const field = document.getElementById('field');
  const grid = document.getElementById('grid');
  if (!gl || !field || !grid) { console.error('Missing #gl/#field/#grid'); return; }
  const fctx = field.getContext('2d'); const gctx = grid.getContext('2d');
  if (!fctx || !gctx) { console.error('2D contexts unavailable'); return; }

  // ---------- Three.js import with CDN fallback (GH Pages friendly) ----------
  let THREE = null;
  const cdns = [
    "https://unpkg.com/three@0.155.0/build/three.module.js",
    "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js"
  ];
  for (let i = 0; i < cdns.length && !THREE; i++) {
    try { THREE = await import(cdns[i]); } catch(e) { /* try next */ }
  }
  if (!THREE) { console.error('Failed to load three.module.js'); return; }

  // ---------- ONE COLOR ONLY (deep blue). Override via ?mono=%231f6feb ----------
  const qp = new URLSearchParams(location.search);
  const MONO_HEX = qp.get('mono') || '#1f6feb'; // single accent
  function hexToVec3(hex){
    const h = hex.replace('#',''); return new THREE.Vector3(
      parseInt(h.slice(0,2),16)/255,
      parseInt(h.slice(2,4),16)/255,
      parseInt(h.slice(4,6),16)/255
    );
  }
  function hexToRGBA(hex,a){const h=hex.replace('#','');return `rgba(${parseInt(h.slice(0,2),16)},${parseInt(h.slice(2,4),16)},${parseInt(h.slice(4,6),16)},${a})`; }
  const MONO_VEC = hexToVec3(MONO_HEX);

  // Push to CSS vars some gentle cloud tints for your background layer
  const root = document.documentElement.style;
  root.setProperty('--t1', MONO_HEX);
  root.setProperty('--t2', MONO_HEX);
  root.setProperty('--t3', MONO_HEX);
  root.setProperty('--t4', MONO_HEX);
  root.setProperty('--cloud1', hexToRGBA(MONO_HEX, .06));
  root.setProperty('--cloud2', hexToRGBA(MONO_HEX, .05));
  root.setProperty('--cloud3', hexToRGBA(MONO_HEX, .05));

  // ---------- Settings ----------
  const isMobile = /Mobi|Android/i.test(navigator.userAgent||'');
  const devMem = navigator.deviceMemory || 4;
  const dpr = window.devicePixelRatio || 1;
  const prefersReduced = matchMedia('(prefers-reduced-motion: reduce)').matches;
  const wantUltra = !isMobile && devMem >= 8 && dpr >= 1.5;
  let quality = qp.get('q') || (wantUltra ? 'ultra' : (isMobile || devMem <= 4 ? 'med' : 'high'));
  const clampRatio = () => (quality === 'high' || quality === 'ultra') ? Math.min(dpr, 2) : 1;

  // ---------- Layout ----------
  let VW = 0, VH = 0;
  function cacheSize(){ const r = gl.getBoundingClientRect(); VW = r.width|0; VH = r.height|0; }
  cacheSize(); addEventListener('resize', cacheSize, { passive: true });

  // ---------- Panel hooks (safe if missing) ----------
  const panel = document.getElementById('panel');
  const panelToggle = document.getElementById('panelToggle');
  if (panelToggle && panel) panelToggle.addEventListener('click', () => panel.classList.toggle('open'));
  const cloudsToggle = document.getElementById('cloudsToggle');
  function setClouds(on){ document.body.classList.toggle('clouds-off', !on); document.body.classList.toggle('clouds-on', on); }
  setClouds(true); if (cloudsToggle) cloudsToggle.addEventListener('change', e => setClouds(e.target.checked));
  const qSel = document.getElementById('quality');
  if (qSel) qSel.addEventListener('change', () => { quality = qSel.value === 'auto' ? (wantUltra?'ultra':(isMobile||devMem<=4?'med':'high')) : qSel.value; hardReset(); });

  // ---------- THREE setup ----------
  let renderer, scene, camera, overlay, cam2, objects = [];
  function initGL(){
    renderer = new THREE.WebGLRenderer({ canvas: gl, antialias: false, alpha: true, powerPreference: 'high-performance' });
    renderer.setClearColor(0x000000, 0);
    renderer.setPixelRatio(clampRatio());
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, 1, 0.1, 400); camera.position.set(0,0,8);
    overlay = new THREE.Scene(); cam2 = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
    resizeGL();
  }
  function resizeGL(){
    renderer.setPixelRatio(clampRatio());
    renderer.setSize(VW, VH, true);
    camera.aspect = (VW||1)/(VH||1); camera.updateProjectionMatrix();
  }
  if ('ResizeObserver' in window) {
    new ResizeObserver(() => { cacheSize(); size2D(); resizeGL(); }).observe(gl);
  } else {
    addEventListener('resize', () => { cacheSize(); size2D(); resizeGL(); }, { passive: true });
  }

  // ---------- Nebula (monochrome) ----------
  function makeNebulaMaterial(){
    return new THREE.ShaderMaterial({
      transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
      uniforms:{uTime:{value:0}, uExposure:{value:0.65}, uMono:{value:MONO_VEC.clone()}},
      vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
      fragmentShader:`precision mediump float; varying vec2 vUv; uniform float uTime,uExposure; uniform vec3 uMono;
        float n(vec2 p){return fract(sin(dot(p,vec2(41.3,289.1)))*43758.5453);}
        float sm(vec2 p){vec2 i=floor(p),f=fract(p);float a=n(i),b=n(i+vec2(1,0)),c=n(i+vec2(0,1)),d=n(i+vec2(1,1));
          vec2 u=f*f*(3.-2.*f);return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y;}
        float fbm(vec2 p){float v=0.,a=.5;for(int i=0;i<6;i++){v+=a*sm(p);p*=2.03;a*=.56;}return v;}
        void main(){
          vec2 uv=vUv*2.; float t=uTime*.03;
          float f=fbm(uv*3.+vec2(t,-t*.7));
          float g=fbm(uv*1.2-vec2(t*.4,t*.2));
          float m=smoothstep(.62,.92,f)*.55 + smoothstep(.68,.94,g)*.45;
          vec3 base=vec3(.015,.06,.12);
          vec3 col = mix(base, uMono, m);                // single hue
          gl_FragColor = vec4(col*uExposure*.8, m*.28);
        }`
    });
  }

  // ---------- Starfield (monochrome) ----------
  function buildStarfield(count){
    const g=new THREE.BufferGeometry();
    const pos=new Float32Array(count*3), spd=new Float32Array(count), phi=new Float32Array(count);
    for(let i=0;i<count;i++){
      const r=38+Math.random()*44; const t=Math.acos(2*Math.random()-1),p=Math.random()*Math.PI*2;
      pos[i*3]=r*Math.sin(t)*Math.cos(p); pos[i*3+1]=r*Math.sin(t)*Math.sin(p); pos[i*3+2]=r*Math.cos(t);
      spd[i]=.02+Math.random()*.06; phi[i]=Math.random()*Math.PI*2;
    }
    g.setAttribute('position',new THREE.BufferAttribute(pos,3));
    g.setAttribute('aSpeed',new THREE.BufferAttribute(spd,1));
    g.setAttribute('aPhi',new THREE.BufferAttribute(phi,1));
    const uni={uTime:{value:0},uMouse:{value:new THREE.Vector3(0,0,0)},uMono:{value:MONO_VEC.clone()}};
    const mat=new THREE.ShaderMaterial({uniforms:uni,transparent:true,depthWrite:false,
      vertexShader:`attribute float aSpeed,aPhi; uniform float uTime; uniform vec3 uMouse; varying float vTw;
        void main(){vec3 p=position; float ang=aSpeed*uTime*.15; float cs=cos(ang),sn=sin(ang); p.xy=mat2(cs,-sn,sn,cs)*p.xy;
        p.x+=uMouse.x*.06; p.y+=uMouse.y*.06; vTw=sin(uTime*.8+aPhi)*.5+.5; gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.); gl_PointSize=1.+1.6*vTw;}`,
      fragmentShader:`precision mediump float; varying float vTw; uniform vec3 uMono;
        void main(){vec2 uv=gl_PointCoord*2.-1.; float d=dot(uv,uv);
          float a=smoothstep(1.,0.,d)*(.16+.2*vTw);
          vec3 c=mix(vec3(1.0), uMono, .25 + .25*vTw);  // same hue, lighter core
          gl_FragColor=vec4(c,a);} `
    });
    const pts=new THREE.Points(g,mat); pts.userData={uni}; return pts;
  }

  // ---------- Galaxy (monochrome) ----------
  function buildGalaxy(count){
    const geo=new THREE.InstancedBufferGeometry();
    geo.setAttribute('position',new THREE.Float32BufferAttribute([0,0,0],3));
    geo.instanceCount=count;
    const rad=new Float32Array(count),th0=new Float32Array(count),dir=new Float32Array(count),nz=new Float32Array(count),typ=new Float32Array(count);
    for(let i=0;i<count;i++){rad[i]=THREE.MathUtils.lerp(.15,6.,Math.pow(Math.random(),.55)); th0[i]=Math.random()*Math.PI*2; dir[i]=(Math.random()<.88)?1:-1; nz[i]=(Math.random()*2-1); typ[i]=(Math.random()<.16)?1:0;}
    geo.setAttribute('i_radius',new THREE.InstancedBufferAttribute(rad,1));
    geo.setAttribute('i_theta0',new THREE.InstancedBufferAttribute(th0,1));
    geo.setAttribute('i_dir',new THREE.InstancedBufferAttribute(dir,1));
    geo.setAttribute('i_noise',new THREE.InstancedBufferAttribute(nz,1));
    geo.setAttribute('i_type',new THREE.InstancedBufferAttribute(typ,1));

    const uni={uTime:{value:0},uMouse:{value:new THREE.Vector3(0,0,0)},uExposure:{value:.58},uSpeed:{value:.58},uMono:{value:MONO_VEC.clone()}};
    const vsh=`attribute float i_radius,i_theta0,i_dir,i_noise,i_type; uniform float uTime,uSpeed; uniform vec3 uMouse; varying float vR,vType,vTw;
      vec2 grav(vec2 p, vec2 q, float m){vec2 d=p-q; float r2=max(dot(d,d),.03); float inv=m/r2; vec2 tang=vec2(-d.y,d.x); return normalize(tang)*inv*.30 + normalize(-d)*inv*.09;}
      void main(){float r=i_radius; float omega=uSpeed*.58*inversesqrt(max(r,.0001)); omega*=mix(1.,.55,step(.5,i_type));
        float th=i_theta0 + i_dir*uTime*omega; vec2 p=vec2(cos(th),sin(th))*r; p+=(.05+.04*i_noise)*vec2(cos(2.1*th+i_noise*5.0),sin(1.9*th-i_noise*4.0));
        vec2 l=grav(p,uMouse.xy,uMouse.z); p+=l*1.5; float z=(i_type>.5?.40:.16)*(fract(sin(i_noise*43758.5453)*1e4)*2.-1.);
        vR=r; vType=i_type; vTw=length(l); gl_Position=projectionMatrix*modelViewMatrix*vec4(p,z,1.);
        float base=mix(.55,1.05,1./(1.+r*.22)); gl_PointSize=base*(1.+3.6*vTw)*(1.+.28*float(i_type<.5));}`;
    const fsh=`precision mediump float; uniform vec3 uMono; uniform float uExposure; varying float vR,vType,vTw;
      void main(){vec2 uv=gl_PointCoord*2.-1.; float d=dot(uv,uv);
        float core=smoothstep(1.,0.,d)*.54; float t=clamp(vR/6.,0.,1.);
        // Single hue with radial lightness variation
        vec3 c = mix(vec3(1.0), uMono, 0.70 + 0.25*t); // inner ~lighter, outer ~deeper same hue
        float g = clamp(vTw*3.6,0.,1.); c += g*.25;
        c *= uExposure;
        gl_FragColor = vec4(c, core*(.58+.22*g));
      }`;
    const mat=new THREE.ShaderMaterial({vertexShader:vsh,fragmentShader:fsh,uniforms:uni,transparent:true,depthWrite:false,blending:THREE.AdditiveBlending});
    const pts=new THREE.Points(geo,mat); pts.userData={uni}; return pts;
  }

  // ---------- Halo (monochrome) ----------
  function buildHalo(count){
    const g=new THREE.BufferGeometry();
    const hPos=new Float32Array(count*2), hPhase=new Float32Array(count), hRad=new Float32Array(count);
    for(let i=0;i<count;i++){const a=Math.random()*Math.PI*2; hPos[i*2]=Math.cos(a); hPos[i*2+1]=Math.sin(a); hPhase[i]=Math.random()*Math.PI*2; hRad[i]=.006+Math.random()*.05;}
    g.setAttribute('aPos',new THREE.BufferAttribute(hPos,2));
    g.setAttribute('aPhase',new THREE.BufferAttribute(hPhase,1));
    g.setAttribute('aRad',new THREE.BufferAttribute(hRad,1));
    const uni={uTime:{value:0},uCursor:{value:new THREE.Vector2(0,0)},uScale:{value:1},uAspect:{value:1},uMono:{value:MONO_VEC.clone()}};
    const mat=new THREE.ShaderMaterial({uniforms:uni,transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,
      vertexShader:`attribute vec2 aPos; attribute float aPhase,aRad; uniform vec2 uCursor; uniform float uScale,uAspect,uTime; varying float vA;
        void main(){float tw=sin(uTime*4.+aPhase)*.5+.5; vec2 base=normalize(aPos)*(0.07+aRad*.9); base.x*=uAspect; vec2 ndc=uCursor+base*uScale; gl_Position=vec4(ndc,0.,1.); gl_PointSize=1.6+2.8*tw; vA=tw; }`,
      fragmentShader:`precision mediump float; varying float vA; uniform vec3 uMono;
        void main(){vec2 q=gl_PointCoord*2.-1.; float d=dot(q,q); float a=smoothstep(1.,0.,d)*mix(.25,.6,vA);
        vec3 col=mix(vec3(1.0), uMono, .6); gl_FragColor=vec4(col,a);} `});
    const pts=new THREE.Points(g,mat); pts.userData={uni}; return pts;
  }

  // ---------- Build scene ----------
  let nebula, starfield, galaxy, halo;
  const starCountEl=document.getElementById('starCount');
  function buildScene(){
    objects.length=0; if (scene) scene.clear(); if (overlay) overlay.clear();
    nebula=new THREE.Mesh(new THREE.PlaneGeometry(40,22,1,1), makeNebulaMaterial()); nebula.position.z=-6; scene.add(nebula); objects.push({type:'neb',mat:nebula.material});
    const BG = (prefersReduced?2800:(quality==='ultra'?22000:quality==='high'?15000:6000));
    starfield=buildStarfield(BG); scene.add(starfield); objects.push({type:'sf',mat:starfield.material,uni:starfield.userData});
    const CNT = (prefersReduced?5400:(quality==='ultra'?45000:quality==='high'?30000:12000));
    if (starCountEl) starCountEl.textContent = CNT.toLocaleString();
    galaxy=buildGalaxy(CNT); scene.add(galaxy); objects.push({type:'gal',mat:galaxy.material,uni:galaxy.userData});
    const HALO = (prefersReduced?110:(quality==='ultra'?520:quality==='high'?320:160));
    halo=buildHalo(HALO); overlay.add(halo); objects.push({type:'halo',mat:halo.material,uni:halo.userData});
  }
  function size2D(){
    const pr = clampRatio();
    field.width = VW*pr; field.height = VH*pr; fctx.setTransform(pr,0,0,pr,0,0);
    grid.width  = VW*pr; grid.height  = VH*pr; gctx.setTransform(pr,0,0,pr,0,0);
    if (halo) halo.userData.uni.uAspect.value = (VW||1)/(VH||1);
  }

  // ---------- Cursor + scroll ----------
  const worldMouse = new THREE.Vector2(0,0);
  let baseMass=.7, mass=.7, spike=0;
  function screenToWorldOnPlane(sx,sy,planeZ=0){
    const nx=(sx/VW)*2-1, ny=-(sy/VH)*2+1; const o=camera.position.clone();
    const v=new THREE.Vector3(nx,ny,.5).unproject(camera); const d=v.sub(o).normalize();
    const t=(planeZ-o.z)/d.z; return new THREE.Vector2(o.x+d.x*t,o.y+d.y*t);
  }
  addEventListener('pointermove', e => {
    const r=gl.getBoundingClientRect(); const nx=((e.clientX-r.left)/r.width)*2-1, ny=-(((e.clientY-r.top)/r.height)*2-1);
    if (halo) halo.userData.uni.uCursor.value.set(nx,ny);
    const p = screenToWorldOnPlane(e.clientX-r.left, e.clientY-r.top, 0); worldMouse.copy(p);
  }, { passive:true });
  addEventListener('click', () => { spike=1; });

  function onScroll(){
    if (!halo || !galaxy) return;
    const maxScroll = Math.max(1, document.documentElement.scrollHeight - innerHeight);
    const p = Math.max(0, Math.min(1, scrollY / maxScroll));
    halo.userData.uni.uScale.value = 1 + 0.25*p; // size only; hue fixed
    // Slight exposure lift with scroll
    galaxy.userData.uni.uExposure.value = .58 + .10*p;
  }
  addEventListener('scroll', onScroll, { passive:true });

  // ---------- 2D field + grid (monochrome lines) ----------
  let seeds=[];
  function seedFlow(){ seeds.length=0; const n = prefersReduced?30:(quality==='ultra'?100:quality==='high'?80:54);
    for(let i=0;i<n;i++){const a=i/n*Math.PI*2,r=1+(i%2)*.22; seeds.push({x:Math.cos(a)*r,y:Math.sin(a)*r});}
  }
  function fVec(x,y){const r2=Math.max(x*x+y*y,.0004),inv=1./Math.pow(r2,.75); let vx=-y*inv,vy=x*inv;
    const dx=x-worldMouse.x,dy=y-worldMouse.y,q2=dx*dx+dy*dy+.02;
    const bend=(quality==='high'||quality==='ultra')?.32:.26, pull=(quality==='high'||quality==='ultra')?.11:.08, grav=mass/q2;
    vx+=(-dy)*grav*bend + (-dx)*grav*pull; vy+=(dx)*grav*bend + (-dy)*grav*pull; return [vx,vy];
  }
  function toScreen(x,y){const v=new THREE.Vector3(x,y,0).project(camera); return [(v.x*.5+.5)*VW,(-v.y*.5+.5)*VH];}
  const FIELD_COL = hexToRGBA(MONO_HEX, .12);
  function drawField(){ if(prefersReduced||document.visibilityState!=='visible') return;
    fctx.clearRect(0,0,VW,VH); fctx.globalCompositeOperation='lighter';
    const steps=(quality==='ultra'?80:quality==='high'?64:44);
    for(let k=0;k<seeds.length;k++){
      let x=seeds[k].x*(3.0+1.9*Math.sin((k*13.1)%6)), y=seeds[k].y*(1.9+1.3*Math.cos((k*7.7)%6));
      let s=toScreen(x,y); fctx.beginPath(); fctx.moveTo(s[0],s[1]);
      for(let i=0;i<steps;i++){const v=fVec(x,y); const v2=fVec(x+v[0]*.01,y+v[1]*.01); x+=v2[0]*.02; y+=v2[1]*.02; s=toScreen(x,y); fctx.lineTo(s[0],s[1]);}
      fctx.strokeStyle=FIELD_COL; fctx.lineWidth=1; fctx.stroke();
    }
    fctx.globalCompositeOperation='source-over';
  }
  function drawGrid(){
    if(document.visibilityState!=='visible') return;
    gctx.clearRect(0,0,VW,VH); gctx.strokeStyle='rgba(255,255,255,0.055)'; gctx.lineWidth=1;
    const step=(quality==='ultra'?36:quality==='high'?40:50), cols=Math.ceil(VW/step)+2, rows=Math.ceil(VH/step)+2;
    for(let j=-1;j<=rows;j++){ gctx.beginPath();
      for(let i=-1;i<=cols;i++){ const sx=i*step, sy=j*step; let p=screenToWorldOnPlane(sx,sy,0);
        const dx=p.x-worldMouse.x,dy=p.y-worldMouse.y,r2=dx*dx+dy*dy+.08; const k=((quality==='high'||quality==='ultra')?.22:.17)*mass/r2;
        p.x+=dx*k; p.y+=dy*k; const q=new THREE.Vector3(p.x,p.y,0).project(camera); const px=(q.x*.5+.5)*VW, py=(-q.y*.5+.5)*VH;
        if(i===-1) gctx.moveTo(px,py); else gctx.lineTo(px,py);
      } gctx.stroke();
    }
    for(let i=-1;i<=cols;i++){ gctx.beginPath();
      for(let j=-1;j<=rows;j++){ const sx=i*step, sy=j*step; let p=screenToWorldOnPlane(sx,sy,0);
        const dx=p.x-worldMouse.x,dy=p.y-worldMouse.y,r2=dx*dx+dy*dy+.08; const k=((quality==='high'||quality==='ultra')?.22:.17)*mass/r2;
        p.x+=dx*k; p.y+=dy*k; const q=new THREE.Vector3(p.x,p.y,0).project(camera); const px=(q.x*.5+.5)*VW, py=(-q.y*.5+.5)*VH;
        if(j===-1) gctx.moveTo(px,py); else gctx.lineTo(px,py);
      } gctx.stroke();
    }
  }

  // ---------- Controls ----------
  const exposureEl=document.getElementById('exposure'), massEl=document.getElementById('mass'), speedEl=document.getElementById('speed');
  if (exposureEl) exposureEl.addEventListener('input',()=>{const e=parseFloat(exposureEl.value)||0.65; if(nebula) nebula.material.uniforms.uExposure.value=e; if(galaxy) galaxy.userData.uni.uExposure.value=e;});
  if (massEl) massEl.addEventListener('input',()=>{baseMass=parseFloat(massEl.value)||.7;});
  if (speedEl) speedEl.addEventListener('input',()=>{const s=parseFloat(speedEl.value)||.58; if(galaxy) galaxy.userData.uni.uSpeed.value=s;});

  // ---------- Loop ----------
  let running=true; document.addEventListener('visibilitychange',()=>running=(document.visibilityState==='visible'));
  let t0=performance.now(), last2D=0; const target2D=()=> (quality==='ultra'||quality==='high')?1/60:1/30;
  function tick(){
    if(!running){ requestAnimationFrame(tick); return; }
    const t=performance.now(), dt=(t-t0)/1000; t0=t;
    const massBias=(quality==='high'||quality==='ultra')?.22:0; mass+=(baseMass+massBias-mass)*.06; if(spike>0){mass+=.5*spike; spike*=.88;}
    const wm=new THREE.Vector3(worldMouse.x,worldMouse.y,mass);
    if (starfield) starfield.userData.uni.uMouse.copy(wm);
    if (galaxy) { const u=galaxy.userData.uni; u.uMouse.copy(wm); const ts=(prefersReduced?.35:(quality==='ultra'?.68:quality==='high'?.58:.48)); u.uTime.value+=dt*ts; }
    if (nebula) nebula.material.uniforms.uTime.value+=dt;
    if (halo) halo.userData.uni.uTime.value+=dt;

    renderer.render(scene,camera);
    renderer.autoClear=false; renderer.clearDepth(); renderer.render(overlay,cam2); renderer.autoClear=true;

    const now=t/1000; if(now-last2D>=target2D()){ drawField(); drawGrid(); last2D=now; }
    requestAnimationFrame(tick);
  }

  // ---------- Boot ----------
  function buildAll(){ objects.length=0; buildScene(); size2D(); seedFlow(); onScroll(); }
  function hardReset(){ initGL(); buildAll(); }
  function initAll(){ initGL(); buildAll(); requestAnimationFrame(tick); }
  initAll();

  // Smoke check
  setTimeout(()=>{ console.assert(scene.children.length>=3,'scene ok'); },300);
})();
</script>
